---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ginne.
--- DateTime: 2020/5/6 15:35
---
local basic = require("STP")


N = 4
M = 4   --表示有多少个而二元逻辑算子
M_n = torch.Tensor({{0,1},{1,0}})
M_c = torch.Tensor({--1222
    {1,0,0,0},
    {0,1,1,1}
})
M_d = torch.Tensor({--1112
    {1,1,1,0},
    {0,0,0,1}
})
M_i = torch.Tensor({--1211
    {1,0,1,1},
    {0,1,0,0}
})
M_e = torch.Tensor({--1221
    {1,0,0,1},
    {0,1,1,0}
})
M_m = torch.Tensor({--2112
    {0,1,1,0},
    {1,0,0,1}
})
function R_matrix(k)
    local ans = torch.zeros(k^2,k)
    for i=1,k,1 do
        ans[1+(k+1)*(i-1)][i] = 1
    end
    return ans
end
function W_matrix(m,n)
    local ans = torch.zeros(m*n,m*n)
    for i=1,m,1 do
        for j=1,n,1 do
            ans[i + (j-1)*m][n*(i-1)+j] = 1
        end
    end
    return ans
end

local I = torch.randperm(N)
local G = torch.rand(N-1)
G = torch.cat(torch.Tensor({-1}),G)

local I1 = torch.Tensor(2,1)
I1[1] = 0
I1[2] = 1
local I3 = torch.Tensor(2,1)
I3[1] = 1
I3[2] = 0
local I4 = torch.Tensor(2,1)
I4[1] = 1
I4[2] = 0
local I2 = torch.Tensor({{0,0,0,0,1,0,0,0},{1,1,1,1,0,1,1,1}})

function between(i,low,up)
    if i>=low and i<up then
        return true
    end
    return false
end
function fun(X,G,I,basic)
    local ans = basic.STP(M_n,X[I[1]])
    for i=2,G:size()[1],1 do
        if G[i] < 1/M then
            ans = basic.STP(basic.STP(M_c,ans),X[I[i]])
        elseif between(G[i],1/M,2/M) then
            ans = basic.STP(basic.STP(M_d,ans),X[I[i]])
        elseif between(G[i],2/M,3/M) then
            ans = basic.STP(basic.STP(M_i,ans),X[I[i]])
        elseif between(G[i],3/M,4/M) then
            ans = basic.STP(basic.STP(M_e,ans),X[I[i]])
        end
    end
    return ans
end
function true_table(G,I,basic)
    local true_value_table = {}
    for i=0,2^N-1,1 do
        local X = {}
        local temp = i
        for j=N,1,-1 do
            if temp>=2^(j-1) then
                table.insert(X,torch.Tensor({{1},{0}}))
                temp = temp - 2^(j-1)
            else
                table.insert(X,torch.Tensor({{0},{1}}))
            end
        end
        local value = fun(X,G,I,basic)
        table.insert(X,value)
        table.insert(true_value_table,X)
    end
    print("---------------")
    print("  truth table")
    print("X1\tX2\tX3\tX4\tvalue")
    local true_set = {}
    local true_set_count = 0
    local false_set = {}
    local false_set_count = 0
    for i,v in ipairs(true_value_table) do
        local temp = ""
        for j,t in ipairs(v) do
            if t[1][1]==1 then
                temp = temp.."T\t"
            else
                temp = temp.."F\t"
            end
        end
        if v[N+1][1][1] == 1 then
            true_set_count = true_set_count + 1
            table.insert(true_set,v)
        else
            false_set_count = false_set_count + 1
            table.insert(false_set,v)
        end
        print(temp)
    end
    --print(true_set)
    print("---------------")
    print("struct matrix")
    local str_matrix = struct_matrix(G,I,basic)
    --local temp = torch.Tensor({{1},{0}})
    --local ans = str_matrix
    --print(str_matrix)
    --for i=1,N,1 do
    --    ans = basic.STP(ans,temp)
    --end
    --print(ans)
    print(str_matrix)
    print("---------------")
    print("disjunctive normal form")
    dis_norm_form(true_set,true_set_count)
    print("---------------")
    print("conjunctive normal form")
    con_norm_form(false_set,false_set_count)
end
function struct_matrix(G,I,basic)
    local math_basic = require("matrixbasic")
    local str_matrix = M_n
    for i=2,G:size()[1],1 do
        if G[i] < 1/M then
            str_matrix = basic.STP(M_c,str_matrix)
        elseif between(G[i],1/M,2/M) then
            str_matrix = basic.STP(M_d,str_matrix)
        elseif between(G[i],2/M,3/M) then
            str_matrix = basic.STP(M_i,str_matrix)
        elseif between(G[i],3/M,4/M) then
            str_matrix = basic.STP(M_e,str_matrix)
        end
    end
    for i=1,N-1,1 do
        for j=1,N-1-i,1 do
            if I[j]>I[j+1] then
                local temp = I[j]
                I[j] = I[j+1]
                I[j+1] = I[j]
                temp = W_matrix(2,2)
                for t=1,j-1,1 do
                    temp = math_basic.Kronecker(torch.eye(2),temp)
                end
                str_matrix = basic.STP(str_matrix,temp)
            end
        end
    end
    return str_matrix
end
function dis_norm_form(true_set,count)
    local temp = ""
    for i,v in ipairs(true_set) do
        temp = temp.."("
        for j=1,N,1 do
            if v[j][1][1] == 0 then
                temp = temp.."~"
            end
            temp = temp.."X"..tostring(j)
            if j<N then
                temp = temp.." ∧ "
            end
        end
        temp = temp..")"
        if i<count then
            temp = temp.." ∨ "
        end
    end
    print(temp)
end
function con_norm_form(false_set,count)
    local temp = ""
    for i,v in ipairs(false_set) do
        temp = temp.."("
        for j=1,N,1 do
            if v[j][1][1] == 0 then
                temp = temp.."~"
            end
            temp = temp.."X"..tostring(j)
            if j<N then
                temp = temp.." ∨ "
            end
        end
        temp = temp..")"
        if i<count then
            temp = temp.." ∧ "
        end
    end
    print(temp)
end


true_table(G,I,basic)
