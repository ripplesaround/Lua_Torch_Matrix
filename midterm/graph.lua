---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ginne.
--- DateTime: 2020/5/2 13:29
---

N = 3

function init()
    -- create graph
    local P = torch.zeros(N,N)
    for i = 1,N,1 do
        for j = 1,N,1 do
            if math.random() >=0.5 then
                P[i][j] = 1
            end
        end
    end
    return P
end
function inc(matrix)
    local P = torch.zeros(N,torch.sum(matrix))
    local flag = 1
    for i = 1,N,1 do
        for j = 1,N,1 do
            if matrix[i][j] == 1 then
                P[i][flag] = -1
                P[j][flag] = 1
                if i==j then
                    P[i][flag] = 2
                end
                flag = flag + 1
            end
        end
    end
    return P
end
function lap(matrix)
    ---- no dir
    --y = torch.sum(matrix, 1)
    -- degree
    --local D = torch.zeros(N,N)
    --for i=1,N,1 do
    --    D[i][i] = y[1][i]
    --end
    --print(D)
    --local L = D - matrix
    --return L

    ---- dir
    return matrix * matrix:t()
end

edge_check = torch.zeros(N,N)
trail_table = {}
flag_eular_half = false
flag_eular = false
flag_hamilton_half = false
flag_hamilton = false
flag_tree = true
flag_forest = false
con_set = torch.zeros(N)
con_set_num = torch.sum(con_set)
function check_edge(current,matrix)
    -- dfs的边界条件
    for i=1,N,1 do
        if matrix[current][i] == 1 and edge_check[current][i] == 0 then
            return false
        end
    end
    return true
end
function max(i,j)
    if i>j then
        return i
    end
    return j
end
function find_trail_point(current,matrix)
    -- dfs
    if check_edge(current,matrix) then
        -- 当前这个点没有边了
        local temp = "trail: "
        local start_point
        local hamilton_array = torch.zeros(N)
        local flag_temp = 0
        local con_set_local = torch.zeros(N)
        for i, v in ipairs(trail_table) do
            if i==1 then
                start_point = v[1]
                hamilton_array[v[1]] = hamilton_array[v[1]] + 1
                con_set_local[v[1]] = 1
            end
            temp = temp.."("
            temp = temp..v[1]
            temp = temp..","
            temp = temp..v[2]
            temp = temp..")"
            con_set_local[v[2]] = 1
            if i == torch.sum(matrix) then
                flag_eular_half =true
                if v[2] == start_point then
                    flag_eular = true
                end
            end
            if i>N and flag_temp>0 then
                flag_temp = -1
            end
            if flag_temp>=0 then
                hamilton_array[v[2]] = hamilton_array[v[2]] + 1
                flag_temp = flag_temp+1
            end
            if flag_tree then
                if hamilton_array[v[2]] > 1 then
                    flag_tree = false
                    flag_forest = false
                end
            end
        end
        -- con_set
        if torch.sum(con_set_local) > con_set_num then
            con_set = con_set_local
            con_set_num = torch.sum(con_set)
        end


        if flag_temp == N then
            flag_temp = 0
            for i=1,N,1 do
                if hamilton_array[i] == 0 or hamilton_array[i] >2 then
                    break
                end
                if not (hamilton_array[i] == 2 and i == start_point) then
                    break
                end
                flag_temp = i
            end
            if flag_temp == N then
                flag_hamilton_half = true
                if hamilton_array[start_point] == 2 then
                    flag_hamilton = true
                end
            end
        end
        --print(temp)
        table.remove(trail_table)
        return
    end
    for i=1,N,1 do
        if matrix[current][i] == 1 and edge_check[current][i] == 0 then
            --print("i ",i)
            table.insert(trail_table,{current,i})
            edge_check[current][i] = 1
            find_trail_point(i,matrix)
            edge_check[current][i] = 0
        end
    end
    table.remove(trail_table)
end
function find_trail(A)
    print("All trails\n--------------------")
    for i=1,N,1 do
        edge_check = torch.zeros(N,N)
        trail_table = {}
        find_trail_point(i,A)
        print("--------------------")
    end
end
function check_eular()
    print("eular_check")
    if flag_eular_half then
        print("half eular graph")
    else
        print("not half eular graph")
    end
    if flag_eular then
        print("eular graph")
    else
        print("not eular graph")
    end
    print("--------------------")
end
function check_hamilton()
    print("hamilton_check")
    if flag_hamilton_half then
        print("half hamilton graph")
    else
        print("not half hamilton graph")
    end
    if flag_hamilton then
        print("hamilton graph")
    else
        print("not hamilton graph")
    end
    print("--------------------")
end
function check_tree(A)
    print("tree_check")
    -- check if it is a forest
    if not flag_tree then
        local y1 = torch.sum(A, 2)
        local y2 = torch.sum(A, 1)
        local y3 = y1+y2
        for i =1,N,1 do
            if y3[i] == 0 then
                flag_forest = true
                print("graoh is a forest")
            end
        end
    end
    if flag_tree and (not flag_forest) then
        print("graoh is a tree")
    else
        print("graph is not a tree / forest")
    end
end
vis = torch.zeros(N)
function creat_con_set(matrix)
    local con_set_name = {}
    print("--------------------")
    for i=1,N,1 do
        if con_set[i] == 1 then
            table.insert(con_set_name,i)
        end
    end
    print("max con subset")
    print(con_set_name)
    --print(vis[1])
    print("--------------------")
    print("disconnecting set")
    -- TODO 确认是有向图还是无向图

    check_connect(matrix,con_set_name[1])
end

function check_connect(matrix,i)
    -- 只用检查一个点是到其他点是否是可达的即可
    vis[i] = 1
    for j=1,N,1 do
        if vis[j] == 0 and matrix[i][j] ==1 then
            check_connect(matrix,j)
        end
    end
end


local A = init()
print("adjacency Matrix")
print(A)
local incidence_matrix = inc(A)
print("incidence matrix")
print(incidence_matrix)
local laplacian_matrix = lap(incidence_matrix)
print("laplacian matrix")
print(laplacian_matrix)

--find_trail(A)
--check_eular()
--check_hamilton()
--check_tree(A)
--
--creat_con_set(A)
print("---")
print(A*A)
print(A*A*A)



