---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ginne.
--- DateTime: 2020/3/3 15:49
---

function Kronecker(x , y)
    local x1 = x:size()[1]
    local x2 = x:size()[2]
    local y1 = y:size()[1]
    local y2 = y:size()[2]
    local num = 0
    local temp = torch.zeros(y1,y2)
    local temp2 = torch.zeros(y1,x2*y2)
    for i = 1,x1,1 do
        temp = torch.zeros(y1,y2)
        for j = 1,x2,1 do
            num = x[i][j]
            --print(num*y)
            if j==1 then
                temp = temp + num*y
            else
                temp = torch.cat(temp,num*y,2)
            end
        end
        --print(temp)
        if i==1 then
            temp2 = temp2 + temp
        else
            temp2 = torch.cat(temp2,temp,1)
        end
    end
    return temp2
end



local A = torch.ceil(10*torch.rand(2, 3))
local B = torch.ceil(10*torch.rand(4, 2))
local C = torch.ceil(10*torch.rand(3, 4))
local a = torch.ceil(10*torch.rand(1))[1]
local b = torch.ceil(10*torch.rand(1))[1]
local c = torch.ceil(10*torch.rand(1))[1]
local basic = require("matrix_basic")


print("A")
print(A)
print("B")
print(B)
print("C")
print(C)
print("a",a,"b",b,"c",c)
print("-----------")

print("problem 2")
print("Kronecker(A,B)")
print(Kronecker(A,B))
print("Kronecker(B,A)")
print(Kronecker(B,A))
print("-----------")

print("problem 3")
print("associative laws")
print("Kronecker (A,Kronecker(B,C))")
print(Kronecker(A,Kronecker(B,C)))
print("Kronecker(Kronecker(A,B),C)")
print(Kronecker(Kronecker(A,B),C))

print("law of distribution: left")
print("Kronecker(aA+bB,C)")
A = torch.ceil(10*torch.rand(2, 3))
B = torch.ceil(10*torch.rand(2, 3))
C = torch.ceil(10*torch.rand(2, 3))
print(Kronecker(a*A+b*B,C))
print("a*Kronecker(A,C)+b*Kronecker(B,C)")
print(a*Kronecker(A,C)+b*Kronecker(B,C))

print("law of distribution: right")
print("Kronecker(A,bB+cC)")
print(Kronecker(c*C+b*B,A))
print("b*Kronecker(A,B)+c*Kronecker(A,C)")
print(b*Kronecker(A,B)+c*Kronecker(A,C))
print("-----------")

print("problem 4")
print("output: Kronecker(f(A),f(B)), f(Kronecker(A,B))")
print("f = transpose")
local At = A:transpose(1,2)
local Bt = B:transpose(1,2)
print(Kronecker(At,Bt),(Kronecker(A,B)):transpose(1,2))
print("f = inverse")

local dim_A = 3
local dim_B = 2
A = torch.ceil(10*torch.rand(dim_A,dim_A))
B = torch.ceil(10*torch.rand(dim_B,dim_B))
local Ain = torch.inverse(A)
local Bin = torch.inverse(B)
print(Kronecker(Ain,Bin),torch.inverse(Kronecker(A,B)))
print("f = trace")
print(torch.trace(A)*torch.trace(B) , torch.trace(Kronecker(A,B)))
print("f = rank")
print(basic.rank(A)*basic.rank(B),basic.rank(Kronecker(A,B)))
print("f = det")
print(basic.det(A)*basic.det(B),(basic.det(A))^dim_B*(basic.det(B))^dim_A,basic.det(Kronecker(A,B)))
